# Package-Driven Design Structure

This project follows **Package-Driven Design (PDD)** principles with a simplified, maintainable structure.

## ğŸ“ New Project Structure

```
internal/
â”œâ”€â”€ auth/           # Authentication domain
â”‚   â”œâ”€â”€ domain.go      # Domain models and errors
â”‚   â”œâ”€â”€ interfaces.go   # Repository and service interfaces
â”‚   â”œâ”€â”€ repository.go  # SQL repository implementation
â”‚   â”œâ”€â”€ service.go      # JWT service implementation
â”‚   â””â”€â”€ usecase.go      # Use case implementations
â”œâ”€â”€ greet/          # Greeting domain
â”‚   â”œâ”€â”€ domain.go      # Domain models
â”‚   â”œâ”€â”€ interfaces.go   # Service and use case interfaces
â”‚   â”œâ”€â”€ service.go      # Greeting service implementation
â”‚   â””â”€â”€ usecase.go      # Hello use case
â”œâ”€â”€ storage/        # Database layer
â”‚   â”œâ”€â”€ connection.go  # Database connection
â”‚   â”œâ”€â”€ migrator.go   # Migration management
â”‚   â”œâ”€â”€ sqlc/          # SQLC generated code
â”‚   â””â”€â”€ seeders/       # YAML-based data seeding
â”œâ”€â”€ server/         # gRPC server setup
â”‚   â”œâ”€â”€ server.go      # Main server implementation
â”‚   â”œâ”€â”€ interfaces.go  # gRPC handler interfaces
â”‚   â”œâ”€â”€ auth_handler.go # Auth gRPC handler
â”‚   â””â”€â”€ greet_handler.go # Greet gRPC handler
â”œâ”€â”€ di/             # Dependency injection (fx)
â”‚   â”œâ”€â”€ app_providers.go      # App-level providers
â”‚   â”œâ”€â”€ auth_providers.go     # Auth domain providers
â”‚   â”œâ”€â”€ greet_providers.go    # Greet domain providers
â”‚   â”œâ”€â”€ storage_providers.go  # Storage layer providers
â”‚   â””â”€â”€ server_providers.go   # Server providers
â””â”€â”€ cmd/
    â””â”€â”€ server/
        â””â”€â”€ main.go       # Application entry point
```

## ğŸ¯ Package Responsibilities

### **auth/** - Authentication Domain**
- **domain.go**: User, AuthResponse, Credentials, error types
- **interfaces.go**: Repository, Service, UseCase interfaces
- **repository.go**: SQL implementation using SQLC
- **service.go**: JWT token service implementation
- **usecase.go**: Signin, ValidateToken, RefreshToken, GetUser use cases

### **greet/** - Greeting Domain**
- **domain.go**: HelloRequest, HelloResponse models
- **interfaces.go**: Service, UseCase interfaces
- **service.go**: Greeting service implementation
- **usecase.go**: Hello use case implementation

### **storage/** - Database Layer**
- **connection.go**: MySQL database connection management
- **migrator.go**: Migration and seeder execution
- **sqlc/**: Type-safe SQL code generated by SQLC
- **seeders/**: YAML-based data seeding system

### **server/** - Server Layer**
- **server.go**: Main gRPC server with lifecycle management
- **interfaces.go**: gRPC handler interfaces
- **auth_handler.go**: Auth service gRPC implementation
- **greet_handler.go**: Greeting service gRPC implementation

### **di/** - Dependency Injection**
- **app_providers.go**: Logger, configuration providers
- **auth_providers.go**: Auth domain dependency providers
- **greet_providers.go**: Greet domain dependency providers
- **storage_providers.go**: Storage layer dependency providers
- **server_providers.go**: Server dependency providers

## ğŸš€ Benefits of Package-Driven Design

1. **Clear Separation**: Each package has a single, clear responsibility
2. **Simple Structure**: Easy to understand and navigate
3. **Domain-Centric**: Business logic organized by domain
4. **Testable**: Each package can be tested independently
5. **Maintainable**: Changes in one domain don't affect others
6. **Scalable**: Easy to add new domains and features

## ğŸ”§ Usage Example

The application is started with minimal code:

```go
func main() {
    app := fx.New(
        di.LoggerModule,      // Logger and config
        di.ConfigModule,

        di.StorageModule,    // Database layer
        di.AuthModule,        // Authentication
        di.GreetModule,       // Greeting

        di.ServerModule,      // gRPC server
    )
    app.Run()
}
```

Each module is self-contained and provides its dependencies through fx. The architecture promotes clean separation of concerns and makes the codebase easier to maintain and extend.